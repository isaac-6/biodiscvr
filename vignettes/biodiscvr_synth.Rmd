---
title: "Biodiscvr: Synthetic Data Case Demo"
date: "`r Sys.Date()`"
toc-title: "Overview"
output: 
  rmarkdown::html_vignette:
    toc: true
    number_sections: true
vignette: >
  %\VignetteIndexEntry{Biodiscvr: Synthetic Data Case Demo}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = TRUE,
  message = FALSE,
  warning = FALSE
)
library(biodiscvr)
library(knitr)
library(dplyr)
library(yaml)
```

# Introduction

The `biodiscvr` package provides a data-driven framework for the discovery of optimized biomarkers. Its showcase focuses on identifying **Composite Value Ratios (CVRs)**: combinations of features mathematically optimized to maximize clinical group separation while minimizing the sample size required for clinical trials.

This vignette serves as a case demonstration using synthetic multi-cohort data.

# Environment Setup

We start by locating the synthetic data and example configuration files bundled with the package, and defining a temporary output directory.

```{r setup_paths}
# Locate package-internal synthetic data and configs
synth_data_dir <- system.file("synthdata", package = "biodiscvr", mustWork = TRUE)
pkg_files      <- system.file("files", package = "biodiscvr", mustWork = TRUE)

# Create a temporary directory for results
output_dir <- file.path(tempdir(), "biodiscvr_demo")
if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
```

# Data Loading and Harmonization

Multi-cohort datasets often use different naming conventions. `biodiscvr` addresses this by applying a harmonization layer:  

1.  **Loading:** `load_datasets()` scans subdirectories for raw data.  
2.  **Preprocessing:** `preprocess_data()` uses a dictionary to rename features and applies inclusion filters.

```{r preprocess}
# Load raw data
raw_data <- load_datasets(root_path = synth_data_dir)

# Harmonize data
preprocessed <- preprocess_data(
  loaded_data = raw_data,
  files_path = pkg_files, 
  config_filename = "config_synth.yaml", 
  dict_suv_filename = "dict_suv_synth.csv",
  verbose = FALSE
)

# Extract harmonized data and config
data_list <- preprocessed$data
config    <- preprocessed$config
```

# Data Inspection

We can now inspect the internal structure of the data frame, displaying technical feature columns.

```{r view_data_table}
# Access the first available group in the first cohort
sample_df <- data_list[[1]][[2]]
total_cols <- ncol(sample_df)
preview_table <- cbind(
  sample_df[1:5, 1:3],
  `...` = "...",
  sample_df[1:5, (total_cols - 3):total_cols]
)

knitr::kable(
  preview_table, 
  caption = "Table 1: Partial view of harmonized data structure showing features."
)
```



# Multi-Cohort Biomarker Discovery

We use a Genetic Algorithm to evaluate feature combinations across the first two cohorts.

```{r discovery}
# E.g., select the first two cohorts
discovery_cohorts <- names(data_list)[1:min(2, length(data_list))]

# Run discovery
results <- biodiscvr_multicohort(
  preprocessed_data = data_list,
  datasets_to_run = discovery_cohorts,
  group = "CI", 
  config = config,
  ga_seed = 42,
  output_dir = output_dir,
  output_csv_name = "multi_cohort_discovery_results.csv"
)

best_biomarker <- results$result_row
```
Because the fitness function is maximized, the steady increase in the ‘Best’ fitness value across generations shows that the genetic algorithm is progressing as expected. Ideally, the final generations should show no further improvement; if needed, you can increase the number of generations (`maxiter` in the configuration) or adjust the number of stagnant generations allowed before early stopping (`run`).


# Interpreting Results

The algorithm identifies well-performing numerator and denominator features. We evaluate success using these metrics:  

*   **SepAB_All:** Group separation ($t$-statistic).  
*   **SSE_All:** Sample Size Estimate.

```{r show_results}
best_biomarker %>% 
  select(regs_numerator, regs_denominator, fitness_value, SepAB_All, SSE_All) %>%
  kable(caption = "Table 2: Top Optimized Multi-Cohort Biomarker")
```
The observed separation statistics (23.8 and 27.3 in the training cohorts) demonstrate robust group discrimination, and the associated sample‑size estimates (SSE ≈ 16 and 18) point to strong statistical efficiency. Notably, the two metrics are well balanced.

# Validation on Independent Data

We now test the discovered biomarker on a "hold-out" cohort (Cohort 3) to ensure generalizability.

```{r evaluation}
# Identify hold-out cohort
hold_out_cohort <- names(data_list)[3]

if (!is.na(hold_out_cohort)) {
  eval_results <- evaluate_biomarkers(
    discovery_results_csv_path = file.path(output_dir, "multi_cohort_discovery_results.csv"),
    prepared_data_list = data_list,
    config = config,
    datasets_to_evaluate = hold_out_cohort,
    groups_to_evaluate = "CI"
  )

  eval_results %>% 
    select(discovery_dataset, SepAB, SSE) %>%
    kable(caption = "Table 3: Generalization Performance on Independent Cohort")
}
```
The independent cohort shows separation and sample size values similar to those from the training data. That’s generally desirable, though it won’t always be the case if the cohorts come from different subpopulations. Either way, the key comparison is should be between biomarkers, not between cohorts.

# Conclusion
This vignette illustrates the complete workflow for multi‑cohort biomarker discovery using biodiscvr, from harmonization to optimization and independent validation. The synthetic example highlights how CVRs can achieve robust group separation while maintaining low sample size requirements, demonstrating the package’s utility for early‑stage biomarker development.

# Session Information
```{r info}
sessionInfo()
```
