% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/search_algorithm.R
\name{.multi_fitness}
\alias{.multi_fitness}
\title{Combine Multiple Fitness Scores}
\usage{
.multi_fitness(fitnesses, reference_vector = NULL, na.rm = FALSE)
}
\arguments{
\item{fitnesses}{A non-empty numeric vector of individual fitness scores.}

\item{reference_vector}{A numeric vector of the same length as \code{fitnesses}
representing the reference or "ideal" profile. If NULL (default), a
vector of all ones is used.}

\item{na.rm}{Logical. Should missing values (NA) be removed before
calculation? Defaults to \code{FALSE}. If \code{FALSE} and NAs are present, the
result will be \code{NA}.}
}
\value{
A single numeric value representing the combined fitness score,
calculated as \code{prod(fitnesses) * (cosine_similarity)^2}. Returns \code{NA}
if \code{na.rm} is \code{FALSE} and \code{NA} values are present in inputs, or if
cosine similarity cannot be computed (e.g., due to zero vectors when
\code{na.rm=TRUE} removes all elements).
}
\description{
Calculates an overall fitness score by combining a vector of individual
fitness scores. The combination involves the product of the scores and
their cosine similarity to a reference vector.
}
\details{
The function first calculates the base fitness as the product of all
non-NA elements in \code{fitnesses} (\code{prod(fitnesses, na.rm = na.rm)}).
It then calculates the cosine similarity between the \code{fitnesses} vector
and the \code{reference_vector}. Cosine similarity measures the cosine of the
angle between two vectors and ranges from -1 (exactly opposite) to 1
(exactly the same direction), with 0 indicating orthogonality.
The formula used is \code{cos(theta) = dot_product(A, B) / (norm(A) * norm(B))}.
The function handles potential division by zero if either vector has a
zero norm after NA removal (in which case cosine similarity is treated as 0).
The final combined fitness is \code{base_fitness * (cosine_similarity)^2}.
Squaring the cosine similarity makes the contribution always positive and
emphasizes alignment (values closer to 1 or -1 contribute more positively
than values closer to 0).

Note: If \code{fitnesses} contains zeros, the \code{base_fitness} (and thus the final
result) will be zero. Consider if this is the desired behavior.
Also, if \code{fitnesses} can contain negative values, the sign of the
\code{base_fitness} will depend on the number of negative values.
}
\examples{
fitness_scores <- c(0.8, 0.9, 0.7)
reference <- c(1, 1, 1) # Aim for high scores
.multi_fitness(fitness_scores, reference)
.multi_fitness(fitness_scores) # Uses default reference of all 1s

fitness_scores_neg <- c(0.8, -0.9, 0.7)
.multi_fitness(fitness_scores_neg) # Note the impact of negative values on prod()

fitness_scores_aligned <- c(2, 4, 6)
reference_aligned <- c(1, 2, 3) # Perfectly aligned direction
.multi_fitness(fitness_scores_aligned, reference_aligned) # Cosine squared will be 1

fitness_scores_orthog <- c(1, 0)
reference_orthog <- c(0, 1) # Orthogonal vectors
.multi_fitness(fitness_scores_orthog, reference_orthog) # Cosine will be 0

.multi_fitness(c(0, 0), c(1, 1)) # Base is 0
.multi_fitness(c(1, 1), c(0, 0)) # Cosine is 0 (due to zero norm)

.multi_fitness(c(1, NA, 2)) # Returns NA
.multi_fitness(c(1, NA, 2), na.rm = TRUE) # Calculates based on c(1, 2)

}
